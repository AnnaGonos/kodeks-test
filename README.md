# kodeks-test


# Решение задач:

## 1. indexProdPage.html - задание исправление страницы к виду, который, с точки зрения кандидата является правильным и исправленным.

- Ссылка на сайт: [здесь](https://annagonos.github.io/kodeks-test/indexProdPage.html)
- Вы можете посмотреть решение [здесь](https://github.com/AnnaGonos/kodeks-test/blob/main/indexProdPage.html).

## 2. frontScript.js - задание исправление скрипта к виду, который, с точки зрения кандидата является правильным и исправленным.
- Вы можете посмотреть решение [здесь](https://github.com/AnnaGonos/kodeks-test/blob/main/frontScript.js) 

## 3. Есть некоторая строка (var str = 'fgfggg';), что будет, если мы возьмем str[0]?

В JS строки индексируемы. Мы получим символ строки по указанному индексу. Индексация строк в JS начинается с нуля. Таким 
образом str[0] представляет первый символ, str[1] — второй, ну и так далее.

Ответ: 'f'

## 4. Почему плохо писать прямо в прототипы базовых типов?

#### Ответ:

Во-первых, писать прямо в прототипы базовых типов (как пример - Object.prototype или Array.prototype) это плохая практика 
из-за того, что может возникнуть конфликт с другими библиотеками или кодом. Т.е. если мы добавим свой метод в прототип, 
то может возникнуть конфликт с другими частями кода или какими-нибудь сторонними библиотеками. В данном случае конфликт 
будет выражаться в: 1) непредсказуемом поведении (изменим прототип базового типа и неожиданно поменяем поведение всех 
объектов этого типа в нашем коде. В итоге это может так же привести к тому, что будет трудно ловить ошибки (особенно если это большой проект))
и в 2) конфликте имен. Возможно, в будущем в стандарт JavaScript добавится новый метод или свойство с таким же именем, 
что и создали мы, то это приведет к поломке существующего кода. Возможно это маловероятная ситуация, но я думаю, что и это надо предусмотреть.

Во-вторых, сама модификация прототипов увеличивает вероятность того, что движок JS будет тратить больше времени на обход цепочки прототипов. Т.е. сделает код медленнее - а как итог: ухудшается производительность.

В-третьих, могут быть и такие ситуации, когда мы хотим использовать код и в другим проектах (ну или с другими библиотеками).
И здесь опять же будут сложности, т.к. изменения в прототипах могут сделать код менее совестимым итрудным для повторного использования.
На выходе получаем ограничение возможности интеграции с другими компонентами или модулями. 

Так же еще если рассмотреть ситуацию, когда приходят новички в команду. Им скорее всего будет сложнее в таком коде разобраться. 
Они могут не сразу понять, откуда берутся определенные методы или свойства. Т.е. код, изменяющий встроенные прототипы, 
становится менее предсказуемым и трудным для понимания.

В общем, краткая выжимка из того, что написала выше. Проблемы в:
    - Конфликты с другими библиотеками или кодом
    - Ухудшение производительности
    - Реюзабилити и совместимость
    - Трудности в поддержке
    - Нарушение принципов инкапсуляции и совместимости

Поэтому лучше использовать вспомогательные функции или модули, функции высшего порядка, а не мутации прототипов. Или же создавать свои собственные классы и утилиты

## 5. Есть массив в котором лежат объекты с датами, отсортировать по датам. 
```
var arr = [{date: '10.01.2017'}, {date: '05.11.2016'}, {date: '21.13.2002'}];
```
Напишите функцию, которая вернет, отсортированный массив.

Решение:

- Вы можете посмотреть решение [здесь](https://github.com/AnnaGonos/kodeks-test/blob/main/tasks/task-5.js)


## 6. Есть несколько слов, определить состоят ли они из одних и тех же букв('кот', 'ток', 'окт')

```
var arr = ['kot', 'tok', 'okt'], arr1 = ['kot', 'tok', 'ott'];
function sameWords(arr) {
...
}
```

Решение:

- Вы можете посмотреть решение [здесь](https://github.com/AnnaGonos/kodeks-test/blob/main/tasks/task-6.js)


## 7. Объяснить в какой последовательности выведутся цифры и почему так.
   ```
   console.log(1);
   setTimeout(function() {
   console.log(2);
   }, 0)
   console.log(3);
   ```

Ответ:

В консоли увидим:
```
1
3
2
```

Это простая задача на синхронные и асинхронные операции. Сначала выполнятся синхронные, т.е. выведется  в консоль 1, потом setTimeout 
добавится в очередь (причем это макротаска). В js события, такие как setTimeout, помещаются в очередь событий (или же по другому 
можно сказать - очередь задач) и выполняются только после завершения текущего стека вызовов (то есть после выполнения всего
синхронного кода). Идем дальше - в консоль выведется 3. Все синхронные таски отработали. Только после завершения текущего стека вызовов, 
JS проверяет очередь задач и находит setTimeout с функцией, которая выводит 2. Эта функция затем выполняется и 2 выводится в консоль.


## 8. Что выведет на экран следующий код?

```
function b(x, y, a) {
    arguments[2] = 10; (*)
    console.log(a);
}
b(1, 2, 3);
```

Ответ: alert(10) 

(*) - здесь мы изменяем третий элемент псевдомассива arguments - индекс 2, на значение 10. Затем вызывается alert(a);





